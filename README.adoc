= AsciiDoctor Literate Programming module
Giuseppe Bilotta <giuseppe.bilotta@gmail.com>
// Settings
:sectnums:
:icons: font
:toc: left
// Styling
:source-highlighter: rouge
:source-language: ruby
// Long URLs
:url-mrt: http://repos.modelrealization.com/cgi-bin/fossil/mrtools/wiki?name=asciidoc+literate+programming

== What is this?

This is a (Ruby) module to add https://en.wikipedia.org/Literate+programming[literate programming] support to https://www.asciidoctor.org/[AsciiDoctor].

In short, literate programming is an approach to writing software and its documentation by prioritizing human language.
A literate programming “source” is composed by text in some documentation system (in this case, AsciiDoctor's flavor of AsciiDoc) that describes the logic,
with interspersed code snippets whose union constitutes the source code as it will be passed to the compiler.

The process of creating the code from the snippets is known as <<tangling>>, while the extraction of the documentation is known as weaving.
The literate programming support we're introducing in AsciiDoctor with this module does not require a separate weaving step,
since the source document is assumed to be a valid AsciiDoctor document,
and should therefore be processable as-is from the standard compiler, even without special modules.

(In fact, this `README.adoc` file is itself a literate-programming source for the module itself.)

== Why is this?

There are previous effort to introduce literate programming features in the AsciiDoc format, including
http://eweb.sourceforge.net/[eWEB] and the {url-mrt}[Model Realization Tools]' `atangle` and `aweave` programs.
So why do we need another one?

More features:: most importantly, support the creation of multiple files from a single document, a feauture that is missing from the existing tools;

Syntax compatibility:: the existing tools have slightly different syntax;
the obvious solution to this is to https://xkcd.com/927/[introduce a new, incompatible syntax],
_but_ the actual plan is to also support the syntax from the other two tools.

Integration:: we hook directly into AsciiDoctor, allowing single-pass processing of a document to produce both the documentation and the source;
the plan is to also include cross-referencing and indexing for the code chunks (but this is not currently implemented).

== How is this?

The module is implemented as an https://docs.asciidoctor.org/asciidoctor/latest/extensions/[Asciidoctor extension].
Since we are only interested in producing secondary outputs, we implement a https://docs.asciidoctor.org/asciidoctor/latest/extensions/tree-processor/[`TreeProcessor`],
that will traverse the document tree to gather all blocks that define chunks.

The processor needs to track some state, so it needs a constructor to initialize it properly. AsciiDoctor
processors take a config on construction, so we follow the convention, although we do not (at present)
make use of any configuration.

.Main class definition
[source]
----
class LiterateProgrammingTreeProcessor < Asciidoctor::Extensions::TreeProcessor
  def initialize config = {}
    super config # <1>
    <<Declare and initialize variables needed by the processor>>
  end

  <<Support methods>>
  <<Tangling methods>>
  <<Processing methods>>
end
----
<1> Rember to call the initializer of the superclass, or the custom processor won't work!

which of course requires the `asciidoctor/extensions` Ruby module that defines the `Asciidoctor::Extensions::TreeProcessor` class:

.Requires
[source]
require 'asciidoctor/extensions'

=== Chunk management

Each chunk is identified by a title, and the corresponding source code may be split across multiple blocks.
The (final) content of a chunk is obtained by the concatenation of all the blocks with the same title.

The title of the chunk is used as a handle, that can be referenced by other chunks to declare that
the content of the referenced chunk should be inlined in the referencing chunk (this inlining process is known as <<tangling>>).
A special kind of chunk is the _root chunk_, that is not referenced by any other chunk and whose title
represents the name of the file to be created.
We support the creation of multiple files from the same source, so we can have multiple root chunks.

The natural data structure to store chunks (be them generic or root chunks) is a `Hash`
that maps the title (a `String`) to the content (an `Array` of ``String``s).
For the processor we need to declare two such hashes:
`@chunks` will hold the generic code chunks, while `@roots` will hold _root chunks_.

Since the source code associated with a generic chunk can be spread out over multiple blocks,
we define a default value constructor for `@chunks`: this will simplify the
process of appending new lines to a value each time we come across a new block.
The root chunk is assumed to be unique per file (i.e. per title), but we still provide the same default value constructor,
since this will allow us handle the extraction in the same way for both types.
Uniqueness of root chunks will be handled explicitly during block processing..

.Declare...
[source]
----
@roots = Hash.new { |hash, key| hash[key] = [] }
@chunks = Hash.new { |hash, key| hash[key] = [] }
----

Chunk titles have no particular syntax restriction, but are conventionally a natural language (synthetic) descriptions of the chunk intended use.
As this can get on the longish side, and typing them multiple times can be time-consuming and error-prone,
they can be shortened to any _unambiguous_ prefix followed by an ellipsis (three dots: `...`).
For example, a chunk may be titled `Automagical creation of bug-free code`, and this may be shortened to `Automagic...`
if there are no other chunks whose title begins with `Automagic`.
We do require that _the first time a chunk title is encountered_ (be it to define it or as a reference in another chunk),
_it must be written out in full_.

To assist in the handling of shortened chunk titles, we keep track of all the (full) titles we've come across
so far:

.Declare...
[source]
----
@chunk_names = Set.new
----

and we provide a support method that will take a (possibly shortened) chunk title and return the full title,
raising an exception if we do not find one (and only one) chunk title starting with the given prefix:

.Support...
[source]
----
def full_title string
  pfx = string.chomp("...")
  # nothing to do if title was not shortened
  return string if string == pfx
  hits = @chunk_names.find_all { |s| s.start_with? pfx }
  raise ArgumentError, "No chunk #{string}" if hits.length == 0
  raise ArgumentError, "Chunk title #{string} is not unique" if hits.length > 1
  hits.first
end
----

=== Tangling [[tangling]]

Tangling is the process of “stitching together” all the code blocks, recursively following the
referenced chunks starting from the root chunk, for each file.

References to other chunks are identified by a chunk title written between double angle brackets
(e.g. `<<(Possibly shortened) chunk title>>`)
on a line of its own, optionally surrounded by whitespace.
When processing chunks line by line, we may want to check if a particular line is a chunk reference,
and if so we'll want the full name of the chunk, as well as any indenting that precedes the reference:

.Support...
[source]
----
def is_chunk_ref line
  if line.match /^(\s*)<<(.*)>>\s*$/
    return full_title($2), $1
  else
    return false
  end
end
----

The recursive tangling of chunks is achieved by starting at the root chunk,
outputting any line that is not a reference to another chunk, and recursively calling
the function any time a reference is encountered.

The data we need to keep track of during the recursion are:
the output stream:: to which we are writing the lines,
the title of the chunk being processed:: to detect circular references and produce meaningful error messages,
the current indent:: added to all lines being output,
the contents of the chunk being processed:: this could be obtained knowing the chunk name _and_ the chunk type,
but by passing the chunk contents itself we can simplify the logic of the method,
the names of the chunks we're in the middle of processing:: this is a `Set` to which chunk names
are added when entering the method and removed on exit, and it is used to detect circular references.

.Tangling...
[source]
----
def recursive_tangle file, chunk_name, indent, chunk, stack
  stack.add chunk_name
  chunk.each do |line|
    ref, new_indent = is_chunk_ref line
    if ref
      # must not be in the stack
      raise RuntimeError, "Recursive reference to #{ref} from #{chunk_name}" if stack.include? ref
      # must be defined
      raise ArgumentError, "Found reference to undefined chunk #{ref}" unless @chunks.has_key? ref
      recursive_tangle file, ref, indent + new_indent, @chunks[ref], stack
    else
      file.puts indent + line
    end
  end
  stack.delete chunk_name
end
----

This needs to be done for each root chunk defined by the document:

.Tangling...
[source]
----
def tangle
  @roots.each do |name, initial_chunk|
    File.open(name, 'w') do |f|
      recursive_tangle f, name, '', initial_chunk, Set[]
    end
  end
end
----

=== Collecting chunks

AsciiDoc's syntax allows us to forego special syntax to identify code chunks: we assume
that any `listing` block in the `source` style is (part of) a code chunk.

When we will add compatibility with the other AsciiDoc-based literate
programming tools, we will also support generic `listing` blocks, with a slightly
different syntax.

Processing of a single block requires us to identify the chunk type (root or generic)
and title, add the title to the known chunk titles (if necessary) and append the
block lines to the chunk contents.
We also check if any of the lines we're adding contain a reference to another chunk,
and if so add the title to the list of known titles, to allow shortened names
to be used henceforth.

.Processing...
[source]
----
def process_block block
  <<Determine chunk type and title, setting chunk_hash and chunk_title>>

  @chunk_names.add chunk_title
  # append the lines TODO preprocessor directives for file and line
  chunk_hash[chunk_title] += block.lines

  <<Check for references and prime the chunk names>>
end
----

A `source` block defines a generic chunk, unless it has the `output` attribute set,
in which case it's a root chunk:

.Determine...
[source]
----
chunk_hash = @chunks
if block.style == "source"
  # is this a root chunk?
  if block.attributes.has_key? 'output'
    <<Handle root chunk>>
  else
    <<Handle generic chunk>>
  end
else
  # TODO check if first line is <<title>>=
  return
end
----

For a root chunk, aside from setting `chunk_hash` and `chunk_title` appropriately,
we also verify that the same file name (i.e. title) is not already defined:

.Handle root chunk
[source]
----
chunk_hash = @roots
chunk_title = block.attributes['output']
raise ArgumentError, "Duplicate root chunk for #{chunk_title}" if chunk_hash.has_key?(chunk_title)
chunk_hash[chunk_title] = []
----

For a generic chunk, we leave `chunk_hash` at the default value, and set the `chunk_title`
from the `title` attribute of the block.

.Handle generic chunk
[source]
----
# We use the block title (TODO up to the first full stop or colon) as chunk name
title = block.attributes['title']
chunk_title = full_title title
# TODO override block title if it was a shorthand prefix
----

Regardless of the chunk type, processing of the block is finished by scanning the lines of the block, to add any
referenced chunk name to `@chunk_names`:

.Check for references...
[source]
----
block.lines.each do |line|
  mentioned, _ = is_chunk_ref line
  @chunk_names.add mentioned if mentioned
end
----

=== Document processing

The document as a whole is processed simply by processing all the listing blocks,
and <<tangling>> the output files:

.Processing...
[source]
----
def process doc
  doc.find_by context: :listing do |block|
    process_block block
  end
  tangle
  doc
end
----


=== The module

The complete module simply assembles what we've seen so far, and registers the extension
with Asciidoctor:

.The module structure
[source,output=literate-programming.rb]
----
<<Requires>>

<<Main class...>>

Asciidoctor::Extensions.register do
  tree_processor LiterateProgrammingTreeProcessor
end
----

