= AsciiDoctor Literate Programming module
Giuseppe Bilotta <giuseppe.bilotta@gmail.com>
// Settings
:sectnums:
:icons: font
:toc: left
:literate-programming-outdir: lib/
// Styling
:source-highlighter: rouge
:source-language: ruby
// Long URLs
:url-mrt: http://repos.modelrealization.com/cgi-bin/fossil/mrtools/wiki?name=asciidoc+literate+programming

== What is this?

This is a (Ruby) module to add https://en.wikipedia.org/Literate+programming[literate programming] support to https://www.asciidoctor.org/[AsciiDoctor].

In short, literate programming is an approach to writing software and its documentation by prioritizing human language.
A literate programming “source” is composed by text in some documentation system (in this case, AsciiDoctor's flavor of AsciiDoc) that describes the logic,
with interspersed code snippets whose union constitutes the source code as it will be passed to the compiler.

The process of creating the code from the snippets is known as <<tangling>>, while the extraction of the documentation is known as weaving.
The literate programming support we're introducing in AsciiDoctor with this module does not require a separate weaving step,
since the source document is assumed to be a valid AsciiDoctor document,
and should therefore be processable as-is from the standard compiler, even without special modules.

(In fact, this `README.adoc` file is itself a literate-programming source for the module itself.)

== Why is this?

There are previous effort to introduce literate programming features in the AsciiDoc format, including
http://eweb.sourceforge.net/[eWEB], https://gitlab.com/slightedsubzero/nowasp[nowasp]
and the {url-mrt}[Model Realization Tools]' `atangle` and `aweave` programs.
So why do we need another one?

Integration:: we hook directly into AsciiDoctor, allowing single-pass processing of a document to produce both the documentation and the source;
the plan is to also include cross-referencing and indexing for the code chunks at the documentation output level (but this is not currently implemented).

More features:: most importantly, support the creation of multiple files from a single document, a feauture that is missing from the existing tools;

Syntax compatibility:: the existing tools have slightly different syntax;
the obvious solution to this is to https://xkcd.com/927/[introduce a new, incompatible syntax],
_but_ the actual plan is to also support the syntax from the other two tools.

== How is this?

The module is implemented as an https://docs.asciidoctor.org/asciidoctor/latest/extensions/[Asciidoctor extension].
Since we are only interested in producing secondary outputs, we implement a https://docs.asciidoctor.org/asciidoctor/latest/extensions/tree-processor/[`TreeProcessor`],
that will traverse the document tree to gather all blocks that define chunks to be output to the secondary files.

The processor needs to track some state, so it needs to override the default constructor (`initialize` method)
to set things up properly.
AsciiDoctor's processors take a configuration `Hash` on construction,
so we follow the convention, even though we do not (at present) make use of any configuration,
and remember to call the superclass' constructor
(otherwise, the extension won't work properly).

.Main class definition
[source]
----
class LiterateProgrammingTreeProcessor < Asciidoctor::Extensions::TreeProcessor
  def initialize config = {}
    super config
    <<Declare and initialize variables needed by the processor>>
  end

  <<Support methods>>
  <<Tangling methods>>
  <<Processing methods>>
end
----

Of course, we need to require the `asciidoctor/extensions` Ruby module to have the `Asciidoctor::Extensions::TreeProcessor` class available:

.Requires
[source]
require 'asciidoctor/extensions'

=== Chunk management

Each chunk is identified by a title, and the corresponding source code may be split across multiple blocks.
The (final) content of a chunk is obtained by the concatenation of all the blocks with the same title.

The title of the chunk is used as a handle, that can be referenced by other chunks to declare that
the content of the referenced chunk should be inlined in the referencing chunk (this inlining process is known as <<tangling>>).
A special kind of chunk is the _root chunk_, that is not referenced by any other chunk and represents the starting point for the tangling process.
We support the creation of multiple files from the same source, so we can have multiple root chunks,
and we use the chunk title to represents the name of the file to be created by each root chunk..

The natural data structure to store chunks (be them generic or root chunks) is a `Hash`
that maps the title (a `String`) to the content (an `Array`).
For the processor we need to declare two such hashes:
`@chunks` will hold the generic code chunks, while `@roots` will hold _root chunks_.

Since the source code associated with a generic chunk can be spread out over multiple blocks,
we define a default value constructor for `@chunks`: this will simplify the
process of appending new lines to a value each time we come across a new block.

The root chunk is assumed to be unique per file (i.e. per title),
but we still provide the same default value constructor,
since this will allow us to handle the extraction in the same way for both types.
Uniqueness of root chunks will be handled explicitly during block processing.

.Declare...
[source]
----
@roots = Hash.new { |hash, key| hash[key] = [] }
@chunks = Hash.new { |hash, key| hash[key] = [] }
----

Chunk titles have no particular syntax restriction, but are conventionally a natural language (synthetic) descriptions of the chunk intended use.
As this can get on the longish side, and typing them multiple times can be time-consuming and error-prone,
they can be shortened to any _unambiguous_ prefix followed by an ellipsis (three dots: `...`).
For example, a chunk may be titled `Automagical creation of bug-free code`, and this may be shortened to `Automagic...`
if there are no other chunks whose title begins with `Automagic`.
We do require that _the first time a chunk title is encountered_ (be it to define it or as a reference in another chunk),
_it must be written out in full_.

To assist in the handling of shortened chunk titles, we keep track of all the (full) titles we've come across
so far:

.Declare...
[source]
----
@chunk_names = Set.new
----

and we provide a support method that will take a (possibly shortened) chunk title and return the full title,
raising an exception if we do not find one (and only one) chunk title starting with the given prefix:

.Support...
[source]
----
def full_title string
  pfx = string.chomp("...")
  # nothing to do if title was not shortened
  return string if string == pfx
  hits = @chunk_names.find_all { |s| s.start_with? pfx }
  raise ArgumentError, "No chunk #{string}" if hits.length == 0
  raise ArgumentError, "Chunk title #{string} is not unique" if hits.length > 1
  hits.first
end
----

=== Chunk contents and metadata [[chunkdef]]

The chunk content is stored as an `Array` whose elements are either
``String``s (the actual chunk lines), or ``Asciidoctor::Reader::Cursor``s,
an Asciidoctor-provided structure that carries information about the origin
(file and line number) of the blocks.

Since, as we mentioned, a chunk may span multiple blocks,
we can easily track information about the origin of each of the component blocks
by storing the corresponding `Cursor` before the corresponding lines,
as detailed in the <<collecting>> section.

=== Metadata output

The origin information for a block can be used to add appropriate metadata to
the output files.
Currently we support writing a C-style `#line` directive for a
given filename `fname` and line number `lineno`:

.Support...
[source]
----
def output_line_directive file, fname, lineno
  file.puts('#line %{lineno} "%{file}"' % { lineno: lineno, file: fname})
end
----

=== Tangling [[tangling]]

Tangling is the process of “stitching together” all the code blocks, recursively following the
referenced chunks starting from the root chunk, for each file.

References to other chunks are identified by a chunk title written between double angle brackets
(e.g. `<<(Possibly shortened) chunk title>>`)
on a line of its own, optionally surrounded by whitespace.
When processing chunks line by line, we may want to check if a particular line is a chunk reference,
and if so we'll want the full name of the chunk, as well as any indenting that precedes the reference:

.Support...
[source]
----
def is_chunk_ref line
  if line.match /^(\s*)<<(.*)>>\s*$/
    return full_title($2), $1
  else
    return false
  end
end
----

The recursive tangling of chunks is achieved by starting at the root chunk,
outputting any line that is not a reference to another chunk, and recursively calling
the function any time a reference is encountered.

The state we need to keep track of during the recursion is composed of:

the output stream:: to which we are writing the lines,
the title of the chunk being processed:: to detect circular references and produce meaningful error messages,
the current indent:: added to all lines being output,
the contents of the chunk being processed:: this could be obtained knowing the chunk name _and_ the chunk type,
but by passing the chunk contents itself we can simplify the logic of the method,
the names of the chunks we're in the middle of processing:: this is a `Set` to which chunk names
are added when entering the method and removed on exit, and it is used to detect circular references.

As mentioned in <<chunkdef>>, the `chunk` is an `Array` whose elements are either
``String``s (the actual chunk lines), or ``Asciidoctor::Reader::Cursor``s (that provide source line information).
We handle the two cases separately, and raise an appropriate exception if we come across something unexpected:

.Tangling...
[source]
----
def recursive_tangle file, chunk_name, indent, chunk, stack
  stack.add chunk_name
  fname = ''
  lineno = 0
  chunk.each do |line|
    case line
    <<Cursor case>>
    <<String case>>
    else
      raise TypeError, "Unknown chunk element #{line.inspect}"
    end
  end
  stack.delete chunk_name
end
----

A `Cursor` always precedes the content lines it refers to.
We use it to update the filename (`fname`) and line number (`lineno`) information,
and we output a line directive, since the upcoming text lines will have a different origin
compared to what has been output so far:

.Cursor case
[source]
----
when Asciidoctor::Reader::Cursor
  fname = line.file
  lineno = line.lineno + 1
  output_line_directive(file, fname, lineno)
----

If the chunk element we're processing is a `String`, this can be either
a reference to another chunk, or an actual content line. In both cases,
we update the current origin line number `lineno`, so that the
origin information is correct if we need to output a new line directive.

In the reference case, we check for circular references or references to undefined chunks
(raising appropriate exceptions), and then recurse into the referenced chunk.
After returning from the referenced chunk, we output a new line directive,
so that subsequent lines from the current chunk have correct origin information metadata.

If the line is not a reference, we just output it as-is, preserving indent,
except for empty strings, in which case the indent is not added.

.String case
[source]
----
when String
  lineno += 1
  ref, new_indent = is_chunk_ref line
  if ref
    # must not be in the stack
    raise RuntimeError, "Recursive reference to #{ref} from #{chunk_name}" if stack.include? ref
    # must be defined
    raise ArgumentError, "Found reference to undefined chunk #{ref}" unless @chunks.has_key? ref
    recursive_tangle file, ref, indent + new_indent, @chunks[ref], stack
    output_line_directive(file, fname, lineno)
  else
    file.puts line.empty? ? line : indent + line
  end
----

The recursive tangling process must be repeated for each root chunk  defined by the document:

.Tangling...
[source]
----
def tangle doc
  <<Prepare output directory>>
  @roots.each do |name, initial_chunk|
    <<Convert name to full_path>>
    File.open(full_path, 'w') do |f|
      recursive_tangle f, name, '', initial_chunk, Set[]
    end
  end
end
----

We allow users to specify where the output files should be placed by overriding
the `literate-programming-outdir` document attribute.
If defined, this must be a path relative to the `docdir`.
The output directory is created if not present:

.Prepare...
[source]
----
docdir = doc.attributes['docdir']
outdir = doc.attributes['literate-programming-outdir']
outdir = File.join(docdir, outdir)
FileUtils.mkdir_p outdir
----

Accessing `FileUtils` introduces a new requirement:

.Requires
[source]
----
require 'fileutils'
----

When tangling a new file, the name provided by the user is considered relative to the (literate programming) output directory:

.Convert...
[source]
----
full_path = File.join(outdir, name)
----


=== Collecting chunks [[collecting]]

AsciiDoc's syntax allows us to forego special syntax to identify code chunks: we assume
that any `listing` block in the `source` style is (part of) a code chunk.

When we will add compatibility with the other AsciiDoc-based literate
programming tools, we will also support generic `listing` blocks, with a slightly
different syntax.

Processing of a single block requires us to identify the chunk type (root or generic)
and title, add the title to the known chunk titles (if necessary) and append the
block lines to the chunk contents.
Since the default value for missing chunks is an empty `Array`,
we can append the new lines directly using the `Array#+=` method,
without special-casing the case for the first block that defines a chunk.

Finally, we check if the new lines reference other chunks,
and if so we add the title to the list of known titles,
to allow shortened names to be used henceforth.

.Processing...
[source]
----
def process_block block
  <<Determine chunk type and title, setting chunk_hash and chunk_title>>

  @chunk_names.add chunk_title
  <<Track source location information>>
  chunk_hash[chunk_title] += block.lines

  <<Check for references and prime the chunk names>>
end
----

A `source` block defines a generic chunk, unless it has the `output` attribute set,
in which case it's a root chunk:

.Determine...
[source]
----
chunk_hash = @chunks
if block.style == "source"
  # is this a root chunk?
  if block.attributes.has_key? 'output'
    <<Handle root chunk>>
  else
    <<Handle generic chunk>>
  end
else
  # TODO check if first line is <<title>>=
  return
end
----

For a root chunk, aside from setting `chunk_hash` and `chunk_title` appropriately,
we also verify that the same file name (i.e. chunk title) is not already defined:

.Handle root chunk
[source]
----
chunk_hash = @roots
chunk_title = block.attributes['output']
raise ArgumentError, "Duplicate root chunk for #{chunk_title}" if chunk_hash.has_key?(chunk_title)
----

For a generic chunk, we leave `chunk_hash` at the default value, and set the `chunk_title`
from the `title` attribute of the block.
If the block title was shortened, we also replace the block title with the full chunk title,
to improve the legibility of the documentation.

.Handle generic chunk
[source]
----
# We use the block title (TODO up to the first full stop or colon) as chunk name
title = block.attributes['title']
chunk_title = full_title title
block.title = chunk_title if title != chunk_title
----

Regardless of the chunk type, processing of the block is finished by scanning the lines of the block, to add any
referenced chunk name to `@chunk_names`:

.Check for references...
[source]
----
block.lines.each do |line|
  mentioned, _ = is_chunk_ref line
  @chunk_names.add mentioned if mentioned
end
----

For each block composing a chunk we want to keep track of where it was defined,
so that this information can be added to the output file if requested.
We do this by pushing the `source_location` metadata of each block
into the corresponding chunk `Array`, right before the corresponding lines:

.Track source location...
[source]
----
chunk_hash[chunk_title].append(block.source_location)
----

For this to work correctly, we need to enable the `sourcemap` feature for the document,
which should be done at the preprocessing stage:

.Enable sourcemap
[source]
----
preprocessor do
  process do |doc, reader|
    doc.sourcemap = true
    nil
  end
end
----

=== Document processing

The document as a whole is processed simply by processing all the listing blocks,
and <<tangling>> the output files:

.Processing...
[source]
----
def process doc
  doc.find_by context: :listing do |block|
    process_block block
  end
  tangle doc
  doc
end
----


=== The module

The complete module simply assembles what we've seen so far, and registers the extension
with Asciidoctor:

.The module structure
[source,output=literate-programming.rb]
----
<<Licensing statement>>

<<Requires>>

<<Main class...>>

Asciidoctor::Extensions.register do
  <<Enable sourcemap>>
  tree_processor LiterateProgrammingTreeProcessor
end
----

== Copyright and licensing information

The software is copyright (C) 2021 by {author}, and is made available under the MIT license.
See the `LICENSE` file for further details.

.Licensing...
[source]
----
# Copyright (C) 2021 Giuseppe Bilotta <giuseppe.bilotta@gmail.com>
# This software is licensed under the MIT license. See LICENSE for details
----

== Missing features and known issues

// I would have loved to use description checklists, but Asciidoctor doesn't seem to support those yet ...

.TODO list
improve chunk title parsing::
the block title should only be used up to the first full stop or colon;
the biggest problem in implementing this is arguably the ambiguity of the full stop vs ellipsis.

support for the eWEB, nowasp and `atangle` syntax::
this will require adjusting the cursor offset for the `lineno` feature based on how the block was defined;
it will also require support inline chunk reference exapnsion, and for `@<<` / `@>>` escaping.

`lineno` configuration::
user should be able to enable/disable the feature, and to set the output template;
this configuration should be global, with the possibility to provide per-file or per-language overrides.

auto-indent configuration::
the preservation of leading whitespace during tangling should be optional
(again, globally + per-file / per-language overrides).

hyperlinks::
references to other chunks should be transformable into hyperlinks to the blocks defining the chunk,
and it should be possible to navigate between such blocks.

selective writing::
in particular, avoid overwriting the destination file if the content would be unchanged;
this is important to support large-scale projects where we want to avoid recompiling unchanged modules.
